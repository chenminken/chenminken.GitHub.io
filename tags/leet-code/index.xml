<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Leet Code - 标签 - ChenMin</title>
        <link>http://imchenmin.com/tags/leet-code/</link>
        <description>Leet Code - 标签 - ChenMin</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 01 Nov 2021 23:14:08 &#43;0800</lastBuildDate><atom:link href="http://imchenmin.com/tags/leet-code/" rel="self" type="application/rss+xml" /><item>
    <title>322.Coin Change</title>
    <link>http://imchenmin.com/leetcode322/</link>
    <pubDate>Mon, 01 Nov 2021 23:14:08 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode322/</guid>
    <description><![CDATA[Coin Change You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. 1]]></description>
</item><item>
    <title>32.Longest Valid Parentheses</title>
    <link>http://imchenmin.com/leetcode32/</link>
    <pubDate>Mon, 01 Nov 2021 23:10:09 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode32/</guid>
    <description><![CDATA[Given a string containing just the characters &lsquo;(&rsquo; and &lsquo;)&rsquo;, find the length of the longest valid (well-formed) parentheses substring. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int longestValidParentheses(string s) { // using stack to process stack&lt;int&gt; v; // 找到所有配对]]></description>
</item><item>
    <title>1028. Recover a Tree From Preorder Traversal</title>
    <link>http://imchenmin.com/leetcode1028/</link>
    <pubDate>Fri, 29 Oct 2021 14:35:42 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode1028/</guid>
    <description><![CDATA[We run a preorder depth-first search (DFS) on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. If the depth of a node is D, the depth of its immediate child is D + 1. The depth of the root node is 0. If a node has]]></description>
</item><item>
    <title>124. Binary Tree Maximum Path Sum</title>
    <link>http://imchenmin.com/leetcode124/</link>
    <pubDate>Fri, 29 Oct 2021 11:09:15 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode124/</guid>
    <description><![CDATA[A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node&rsquo;s values in the path. Given the root of a binary]]></description>
</item><item>
    <title>113. Path Sum II</title>
    <link>http://imchenmin.com/leetcode113/</link>
    <pubDate>Fri, 29 Oct 2021 11:06:41 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode113/</guid>
    <description><![CDATA[Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node reference. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. 1 2 3 4]]></description>
</item><item>
    <title>112. Path Sum</title>
    <link>http://imchenmin.com/leetcode112/</link>
    <pubDate>Fri, 29 Oct 2021 11:06:39 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode112/</guid>
    <description><![CDATA[Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool hasPathSum(TreeNode* root, int targetSum, int]]></description>
</item><item>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link>http://imchenmin.com/leetcode105/</link>
    <pubDate>Fri, 29 Oct 2021 11:05:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode105/</guid>
    <description><![CDATA[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0),]]></description>
</item><item>
    <title>99 Recover Binary Search Tree</title>
    <link>http://imchenmin.com/leetcode99/</link>
    <pubDate>Fri, 29 Oct 2021 09:06:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode99/</guid>
    <description><![CDATA[You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38]]></description>
</item><item>
    <title>94Binary Tree Inorder Traversal</title>
    <link>http://imchenmin.com/leetcode94/</link>
    <pubDate>Fri, 29 Oct 2021 08:58:46 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode94/</guid>
    <description><![CDATA[Given the root of a binary tree, return the inorder traversal of its nodes' values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {}]]></description>
</item><item>
    <title>LeetCode26</title>
    <link>http://imchenmin.com/leetcode26/</link>
    <pubDate>Mon, 23 Nov 2020 19:37:45 &#43;0000</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode26/</guid>
    <description><![CDATA[关键词：数组去重 题目描述： Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. 这道题需要更改原始输入的数组]]></description>
</item></channel>
</rss>
