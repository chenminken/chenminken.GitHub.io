<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 标签 - ChenMin</title>
        <link>http://imchenmin.com/tags/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 标签 - ChenMin</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 03 Nov 2021 22:55:04 &#43;0800</lastBuildDate><atom:link href="http://imchenmin.com/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>23.Merge k Sorted Lists</title>
    <link>http://imchenmin.com/leetcode23/</link>
    <pubDate>Wed, 03 Nov 2021 22:55:04 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode23/</guid>
    <description><![CDATA[You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public:]]></description>
</item><item>
    <title>21. Merge Two Sorted Lists</title>
    <link>http://imchenmin.com/leetcode21/</link>
    <pubDate>Wed, 03 Nov 2021 22:55:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode21/</guid>
    <description><![CDATA[Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists. 这道题重点在 dummy 节点上。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class]]></description>
</item><item>
    <title>300.Longest Increasing Subsequence</title>
    <link>http://imchenmin.com/leetcode300/</link>
    <pubDate>Tue, 02 Nov 2021 14:34:58 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode300/</guid>
    <description><![CDATA[Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //]]></description>
</item><item>
    <title>53. Maximum Subarray</title>
    <link>http://imchenmin.com/leetcode53/</link>
    <pubDate>Tue, 02 Nov 2021 14:34:18 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode53/</guid>
    <description><![CDATA[Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum . A subarray is a contiguous part of an array. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; for (int i=1; i&lt;dp.size(); i++) {]]></description>
</item><item>
    <title>322.Coin Change</title>
    <link>http://imchenmin.com/leetcode322/</link>
    <pubDate>Mon, 01 Nov 2021 23:14:08 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode322/</guid>
    <description><![CDATA[Coin Change You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. 1]]></description>
</item><item>
    <title>32.Longest Valid Parentheses</title>
    <link>http://imchenmin.com/leetcode32/</link>
    <pubDate>Mon, 01 Nov 2021 23:10:09 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode32/</guid>
    <description><![CDATA[Given a string containing just the characters &lsquo;(&rsquo; and &lsquo;)&rsquo;, find the length of the longest valid (well-formed) parentheses substring. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int longestValidParentheses(string s) { // using stack to process stack&lt;int&gt; v; // 找到所有配对]]></description>
</item><item>
    <title>1028. Recover a Tree From Preorder Traversal</title>
    <link>http://imchenmin.com/leetcode1028/</link>
    <pubDate>Fri, 29 Oct 2021 14:35:42 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode1028/</guid>
    <description><![CDATA[We run a preorder depth-first search (DFS) on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. If the depth of a node is D, the depth of its immediate child is D + 1. The depth of the root node is 0. If a node has]]></description>
</item><item>
    <title>124. Binary Tree Maximum Path Sum</title>
    <link>http://imchenmin.com/leetcode124/</link>
    <pubDate>Fri, 29 Oct 2021 11:09:15 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode124/</guid>
    <description><![CDATA[A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node&rsquo;s values in the path. Given the root of a binary]]></description>
</item><item>
    <title>113. Path Sum II</title>
    <link>http://imchenmin.com/leetcode113/</link>
    <pubDate>Fri, 29 Oct 2021 11:06:41 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode113/</guid>
    <description><![CDATA[Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node reference. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. 1 2 3 4]]></description>
</item><item>
    <title>112. Path Sum</title>
    <link>http://imchenmin.com/leetcode112/</link>
    <pubDate>Fri, 29 Oct 2021 11:06:39 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode112/</guid>
    <description><![CDATA[Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: bool hasPathSum(TreeNode* root, int targetSum, int]]></description>
</item></channel>
</rss>
