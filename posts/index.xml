<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - ChenMin</title>
        <link>http://imchenmin.com/posts/</link>
        <description>所有文章 | ChenMin</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 29 Oct 2021 14:35:42 &#43;0800</lastBuildDate><atom:link href="http://imchenmin.com/posts/" rel="self" type="application/rss+xml" /><item>
    <title>1028. Recover a Tree From Preorder Traversal</title>
    <link>http://imchenmin.com/leetcode1028/</link>
    <pubDate>Fri, 29 Oct 2021 14:35:42 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode1028/</guid>
    <description><![CDATA[We run a preorder depth-first search (DFS) on the root of a binary tree.
At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. If the depth of a node is D, the depth of its immediate child is D + 1. The depth of the root node is 0.
If a node has only one child, that child is guaranteed to be the left child.]]></description>
</item><item>
    <title>124. Binary Tree Maximum Path Sum</title>
    <link>http://imchenmin.com/leetcode124/</link>
    <pubDate>Fri, 29 Oct 2021 11:09:15 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode124/</guid>
    <description><![CDATA[A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node&rsquo;s values in the path. Given the root of a binary]]></description>
</item><item>
    <title>113. Path Sum II</title>
    <link>http://imchenmin.com/leetcode113/</link>
    <pubDate>Fri, 29 Oct 2021 11:06:41 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode113/</guid>
    <description><![CDATA[Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node reference.
A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution { public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) { vector&lt;int&gt; currentPath; pathSum(root, targetSum, currentPath, 0); return result; } void pathSum(TreeNode* root, int targetSum, vector&lt;int&gt; currentPath, int currentSum) { if (root == NULL) { return; } currentPath.]]></description>
</item><item>
    <title>112. Path Sum</title>
    <link>http://imchenmin.com/leetcode112/</link>
    <pubDate>Fri, 29 Oct 2021 11:06:39 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode112/</guid>
    <description><![CDATA[Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
A leaf is a node with no children.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution { public: bool hasPathSum(TreeNode* root, int targetSum, int currentSum=0) { if (root == NULL) { return false; } currentSum += root-&gt;val; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { if (currentSum !]]></description>
</item><item>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <link>http://imchenmin.com/leetcode105/</link>
    <pubDate>Fri, 29 Oct 2021 11:05:32 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode105/</guid>
    <description><![CDATA[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0),]]></description>
</item><item>
    <title>99 Recover Binary Search Tree</title>
    <link>http://imchenmin.com/leetcode99/</link>
    <pubDate>Fri, 29 Oct 2021 09:06:20 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode99/</guid>
    <description><![CDATA[You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  class Solution { public: TreeNode* prev, * first, * second; void recoverTree(TreeNode* root) { inorder(root); swap(first-&gt;val, second-&gt;val); } void inorder(TreeNode* root) { if (root == NULL) { return; } inorder(root-&gt;left); //code here  if (prev !]]></description>
</item><item>
    <title>94Binary Tree Inorder Traversal</title>
    <link>http://imchenmin.com/leetcode94/</link>
    <pubDate>Fri, 29 Oct 2021 08:58:46 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/leetcode94/</guid>
    <description><![CDATA[Given the root of a binary tree, return the inorder traversal of its nodes' values.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; ret; if (root == nullptr) { return ret; } ret.]]></description>
</item><item>
    <title>不会吧2021年还在用印象笔记?（附快捷迁移指南）</title>
    <link>http://imchenmin.com/yinxiang-replace/</link>
    <pubDate>Thu, 28 Oct 2021 08:04:06 &#43;0000</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/yinxiang-replace/</guid>
    <description><![CDATA[这篇文章是“讨伐”印象笔记的。并且给出快捷迁移印象笔记中的数据的方式 印象笔记对我的影响 我是在2014年高中的时候开始使用印象笔记。当时是在一]]></description>
</item><item>
    <title>YOLOv5 代码结构分析</title>
    <link>http://imchenmin.com/yolov5-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link>
    <pubDate>Thu, 22 Apr 2021 08:04:06 &#43;0000</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/yolov5-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>如何让小爱同学在指定日历创建日程</title>
    <link>http://imchenmin.com/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%B0%8F%E7%88%B1%E5%90%8C%E5%AD%A6%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%97%A5%E5%8E%86%E5%88%9B%E5%BB%BA%E6%97%A5%E7%A8%8B/</link>
    <pubDate>Sun, 07 Feb 2021 15:54:16 &#43;0000</pubDate>
    <author>作者</author>
    <guid>http://imchenmin.com/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%B0%8F%E7%88%B1%E5%90%8C%E5%AD%A6%E5%9C%A8%E6%8C%87%E5%AE%9A%E6%97%A5%E5%8E%86%E5%88%9B%E5%BB%BA%E6%97%A5%E7%A8%8B/</guid>
    <description><![CDATA[在使用iPhone的时候。icloud和Siri让我总有那么一种“周到”的感觉。而小米在这一方面则显得十分的不足。其中我个人在使用中感受到的]]></description>
</item></channel>
</rss>
